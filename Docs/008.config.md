# ConfigNode

The config node system is used for adddon configurations, it's designed on the saved variables, but will black box the details. Please don't use it combined with SVMananger(you still can use it, but not recommend).

The config nodes are pre-defined, we can declare the config field with data type and the field value handler, so the system can learn how to automatically generate the config UI panel for the addon.

When you start using the config nodes, the config panel will be automatically generated based on the those declarations.


## A simple start

Here is an example addon to show how to use the config node system, a simple addon have one saved variables:

```toc
## Interface: 90205
## Dependencies: Scorpio
## SavedVariables: TestAddonSave

# Core
TestAddon.lua
```

With one config node field:

```lua
Scorpio "TestAddon" ""

function OnLoad()
	-- Binding the _Config with the saved variables
	-- Must be used within the OnLoad
	_Config:SetSavedVariable("TestAddonSave")
end

-- Declare a field "log" to the _Config with default value 3
-- the function's content will be called when player entering the game
-- or the field value changed
-- The "log" is the field name
__Config__(_Config, "log", 3)
function SetLogLevel(lvl)
	print("[Config]Log Level is", lvl)
end

--- Declare a slash command to change the log level of the addon
__SlashCmd__ "test" "log"
function OnSlashCmdLogLevel(lvl)
	-- Call the SetLogLevel to change the level
    SetLogLevel(floor(lvl))
end
```

So, with the addon:

1. Entering the game, it'll print the `[Config]Log Level is 3`.
2. Then use `/test log 1`, it'll print `[Config]Log Level is 1`.
3. Reload the game, it'll print `[Config]Log Level is 1`, so the field data is saved and can be reloaded.

The main purpose of the config node system is to split the saved variable declaration and handlers to where it's used, keep using the pure function code style to simple the codes, with those field and data type informations, a config ui panel can be automatically generated.

We use `3` as the default value of the `log` field, the field will be declared to accept **Number** value only.

The field value type can be any enum or struct type, we'll see the details later. Based on the types, the system can choose the matched UI widget to show or modify the field value when the **auto-gen config panel** is used.

As you can see, the `SetLogLevel` used in `OnSlashCmdLogLevel` is not the same we defined, with the `__Config__` attribute, the `SetLogLevel` is replaced by a new function that will validate the input value and save the value to the relative field.

When the field value is changed, an observable subject will distribute the changes, the original `SetLogLevel` that we declared as the handler has already subscribed the subject, so it'll receive the updatings and print out the result.

With the observable subject, we can use the **Style** system to bind the config node field's value to UI elements for direct usages, so we can achieve bidirectional binding.


## Global, Char, Spec, WarMode Config Node

In the example, `_Config` is used to bind saved variable, and used to declare the config field with handlers by `__Config__`. Just like `_Addon`, `_Name`, the `_Config` is a property of the Scorpio Modules, it'll only be created when it's accessed for the first time.

The `_Config` represents the global config for all the characters, there are config nodes for other usages:

1. `_Config` as the **Global** config for all characters.

2. `_CharConfig` for each **Character**, `_CharConfig` can use `SetSavedVariable` method bind a new saved variable for the character only, or it'll use the global saved variable to save it's config data.

3. `_SpecConfig` for character's **Specialization**(In classic, the specialization will always be 1).

4. `_WarModeConfig` for specialization's **Warmode**(pve, pvp, in classic, the warmode will always be pve).

So, when player switch the specialization, the spec config node will be re-inited by the saved variables, and all the handlers will receive the new field values, the warmode config node works the same way.

The `_SpecConfig` and `_WarModeConfig`  can't use the `SetSavedVariable`.

Now, we can have a more complex example:

```toc
## Interface: 90205
## Dependencies: Scorpio
## SavedVariables: TestAddonSave
## SavedVariablesPerCharacter: TestAddonCharSave

# Core
TestAddon.lua
```

```lua
Scorpio "TestAddon" ""

function OnLoad()
	-- Binding the config nodes with the saved variables
	_Config:SetSavedVariable("TestAddonSave")
	_CharConfig:SetSavedVariable("TestAddonCharSave")
end

-- Declare a field "log" to the _Config with default value 3
__Config__(_Config, "log", 3)
function SetLogLevel(lvl)
	print("[Config]Log Level is", lvl)
end

-- The data type is member struct with two members, data like `{ x = 1, y = 3 }`
__Config__(_CharConfig, "location", {
	x = Number,
	y = Number
})
function SetLocation(loc)
	print("[CharConfig]Location is", Toolset.tostring(loc))
end

-- The data type is an array of number, data like `{1, 2, 3, 4, 5 }`
__Config__(_SpecConfig, "action", { Number })
function SetActions(actions)
	print("[SpecConfig]Actions are", Toolset.tostring(actions))
end

-- The data type is Boolean, data like `true|false`, default true
__Config__(_WarModeConfig, "mode", true)
function SetWarMode(mode)
	print("[WarModeConfig]Mode is", mode)
end
```

The usage of `__Config__`  is

```lua
__Config__(configNode[, name][, type][, default])
```

It's combined with four elements:

1. `configNode`: the config node, required.

2. `name`, the field name, optional, the function name will be used if not provided.

3. `type`, the field data type, optional, it can be any scalar, enum, member struct or array type. The system can figure out the scalar data type based on the default value(Number, String, Boolean), the type can be the data type or a table to describe the struct.

4. `default`, the field default value, optional.


## Config Node

The config node is the container of node fields. It also can contains sub-config nodes. You can take the sub-nodes as field groups.

Besides the pre-defined config nodes like `_Config`. We can simply get the sub-node by `_Config[SubNodeName]`, here is an example:

```lua
Scorpio "TestAddon" ""

form = Dialog("Test")

__Config__(_Config.Panel, "visible", true)
function SetPanelVisible(val)
	form:SetShown(val)
end
```

The sub-nodes can be created when first time accessed. And `_CharConfig` is a sub-node of the `_Config` if the `_CharConfig` don't bind its own saved variable, the `_SpecConfig` is the sub-node of the `_CharConfig`, the `_WarModeConfig` is the sub-node of the `_SpecConfig`.


## Node Field

The field name can be provided in the `__Config__`, or use the function name as the field name directly. When a field is declared, we can access the field by `_Config[field]`, the result is an observable subject:

```lua
Scorpio "TestAddon" ""

form = Dialog("Test")

__Config__(_Config.Panel, "visible", true)
function SetPanelVisible(val)
	-- the current value can be fetched from the subject or the argument
	assert(val == _Config.Panel.visible:GetValue())
end

-- Bind the field to the form's visible style
Style[form].visible = _Config.Panel.visible
```

We can access the sub node and field with the same code pattern, the sub node will be create automatically when accessed, the field can only be accessed after declaration.


## Node Field Type

All node field has types, the **PLoop** has provided the data type framework, but we don't need go deep into the **PLoop**, we can learn how to declare them in the below examples.
54

### Scalar Type

For now serveral scalar types provided, we can create more but normally there is no need to do.

* Boolean
* String
* Number
* PositiveNumber
* NegativeNumber
* Integer
* NaturalNumber
* NegativeInteger
* RangeValue[{min, max[, step]}]

The range value is special, a **silder bar** will be used to display that, the value is between [min, max] and with the given step.
The `RangeValue` is a templats struct type, it can receive several template parameters for advanced usages.

```lua
Scorpio "TestAddon" ""

-- The opactity can only between [0, 1], step is 0.01, and the default is 1
__Config__(_Config, "opacity", RangeValue[{0, 1, 0.01}], 1)
function SetOpacity(val)
	print("The opacity is " .. val)
end
```

It's a little complex to explain the template, since there is no other template struct types should be used, just follow the example.


### Enum Type

Besides those scalar types, enum values can be used, the system will use a **comboBox** for the data type. enum value can be simply defined:

```lua
enum "FlyoutDirection" {
    "UP",
    "DOWN",
    "LEFT",
    "RIGHT",
}

-- Usages
print(FlyoutDirection.DOWN) -- DOWN
```

There are a lots of the enum types already defined, you can find them at [Scorpio.UI/Property.lua](https://github.com/kurapica/Scorpio/blob/master/Modules/UI/UI.lua), those can be used directly:

```lua
Scorpio "TestAddon" ""

-- The config for framestrata, default is "MEDIUM"
__Config__(_Config.Panel, "frameStrata", FrameStrata, FrameStrata.MEDIUM)
function SetFrameStrata(val)
end

form = Dialog("Test")
Style[form].FrameStrata = _Config.Panel.frameStrata
```


### Member Struct Type

The member struct type are tables with fixed fields:

```lua
Scorpio "TestAddon" ""

__Config__(_Config, "player", {
	name = String,
	level = Number,
	lastPos = {
		mapid = String,
		x = RangeValue[{0, 1, 0.01}],
		y = RangeValue[{0, 1, 0.01}]
	}
})
function SetPlayerInfo(loc)
	print("[CharConfig]Location is", Toolset.tostring(loc))
end

-- The usage
SetPlayerInfo {
	name = "King",
	level = 50,
	lastPos = {
		mapid = "123123",
		x = 0.54,
		y = 0.12,
	}
}
```

We can use table to declare the member struct, the field value can be any scalar type or enum type, also can be another member struct type or other struct types.


### Array Struct Type

The array struct type are arrays with the values of the given type:

```lua
Scorpio "TestAddon" ""

--- Use number as elements
__Config__(_Config, "spells", { Number })
function SetBuffIds(ids)
end

-- The usages
SetBuffIds{ 12332, 1232, 12323, 1233}

--- use a complex struct as elements
__Config__(_Config, "actionbars", {
	-- A table means a new struct type
	{
		-- instead of the Number type, we can give the default value with type
		row = { type = Number, default = 1 },
		col = { type = Number, default = 12 },

		-- the actions on the bar, also should be an array
		actions = {
			-- Define a new member struct type as the elements of the actions
			{
				type = String,   -- the action type
				action = String, -- the action content
			}
		}
	}
})
function SetActionBars(bars)
	-- Refresh the action bars
end

-- The usage
SetActionBars {
	-- action bar [1]
	{
		row = 1,
		col = 2,
		actions = {
			-- action [1]
			{
				type = "macro"
				action = "/hi"
			},
			-- action [2]
			{
				type = "spell",
				action = "121311",
			}
		}
	},
	-- action bar [2]
	{
		row = 1,
		col = 1,
		actions = {
			-- action [1]
			{
				type = "macro"
				action = "/bye"
			},
		}
	},
}
```

We can build a complex data struct just with table declarations.


### Dictionary Struct Type

The member struc use fixed name fields, if we need dynamic value for the field, we should use the dictionary struct type:

```lua
Scorpio "TestAddon" ""

-- The filters use number value as key and use Boolean as the value
__Config__(_Config, "filters", { [Number] = Boolean })
function SetBuffFilters(filters)
end

SetBuffFilters{
	[123213] = true,
	[123232] = false,
	[111111] = true,
}
```

You should keep use the scalar type or enum type as the key data type.


## Default Value

Although we have see the default value in the member struct declarations, it's just used when a new settings is added. The config field need default value when player first used. They are be given as the last parameter in the `__Config__`, the value must match the given data type.

If the data type not provided, and the default value is a number, boolean or string, the `Number`, `Boolean`, `String` will be used as the data type.


## Observable Node Field

It's a little counterintuitive, when a node field is declared, you can't use `_Config.Field` to get its value, instead you need use `_Config.Field:GetValue()`.

Its a [ConfigSubject](https://github.com/kurapica/Scorpio/blob/master/Modules/Config/ConfigSubject.lua), with it you can:

1. Use `subject:GetValue()` to get the current value.

2. Use `subject:SetValue(val)` to set a new field value.

3. Use `subject:Subscribe(handler)` to bind a new field value handler, it won't remove the existed value handler.

4. Use `Style[frame][prop] = subject` to bind the field value to a frame's property, you can use `subject:Map(function(v) return v.x end)` to map the field value to the proper value for the frame.

So, with the field value subject, we can do the bidirectional binding between the config and the config ui. Normally to say, we won't use the field value subjects directly, it's an advanced feature if you want make your own auto-gen config panel system based on it.


## Auto-gen config panel





## Widgets For Node Fields